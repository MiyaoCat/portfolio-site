"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.documentToPlainTextString = void 0;
var rich_text_types_1 = require("@contentful/rich-text-types");
/**
 * Returns the text value of a rich text document.
 *
 * NB: This can be applied to non text node of a structured text document,
 * hence the flexible typing.
 */
function documentToPlainTextString(rootNode, blockDivisor) {
    if (blockDivisor === void 0) { blockDivisor = ' '; }
    if (!rootNode || !rootNode.content) {
        /**
         * Handles edge cases, such as when the value is not set in the CMA or the
         * field has not been properly validated, e.g. because of a user extension.
         * Note that we are nevertheless strictly type-casting `rootNode` as
         * Block | Inline. Valid rich text documents (and their branch block nodes)
         * should never lack a Node[] `content` property.
         */
        return '';
    }
    /**
     * Algorithm notes: We only want to apply spacing when a node is part of a
     * sequence. This is tricky because nodes can often be deeply nested within
     * non-semantic content arrays. For example, to get the text value of an
     * unordered list, we have to traverse like so:
     *
     * {
     *   nodeType: BLOCKS.UL_LIST,
     *   data: {},
     *   content: [
     *     {
     *       nodeType: BLOCKS.LIST_ITEM,
     *       data: {},
     *       content: [{
     *         nodeType: BLOCKS.PARAGRAPH,
     *         data: {},
     *         content: [
     *           { nodeType: 'text', data: {}, value: 'List ', marks: [] },
     *           { nodeType: 'text', data: {}, value: 'item', marks: [{ type: 'bold' }] }
     *         ]
     *       }]
     *     },
     *     {
     *       nodeType: BLOCKS.LIST_ITEM,
     *       data: {},
     *       content: [{
     *         nodeType: BLOCKS.PARAGRAPH,
     *         data: {},
     *         content: [
     *           { nodeType: 'text', data: {}, value: 'Another list item', marks: [] }
     *         ]
     *       }]
     *     },
     *     {
     *       nodeType: BLOCKS.LIST_ITEM,
     *       data: {},
     *       content: [{
     *         nodeType: BLOCKS.HR,
     *         data: {},
     *         content: [],
     *       }]
     *     },
     *     {
     *       nodeType: BLOCKS.LIST_ITEM,
     *       data: {},
     *       content: [{
     *         nodeType: BLOCKS.PARAGRAPH,
     *         data:
     *         content: [
     *           { nodeType: 'text', data: {}, value: 'Yet another list item', marks: [] }
     *         ]
     *       }]
     *     },
     *   }]
     * }
     *
     * We want there to be a space between 'List item' and 'Another list item' (to
     * denote a visual line break, which conventionally appears between non-text
     * node sequences) but not a redundant space between 'List ' and 'item'.
     * Moreover, we want just a _singular_ space between 'Another list item' and
     * 'Yet another list item' - the non-semantic HR between the two nodes should
     * not denote an additional space.
     */
    return rootNode.content.reduce(function (acc, node, i) {
        var nodeTextValue;
        if (rich_text_types_1.helpers.isText(node)) {
            nodeTextValue = node.value;
        }
        else if (rich_text_types_1.helpers.isBlock(node) || rich_text_types_1.helpers.isInline(node)) {
            nodeTextValue = documentToPlainTextString(node, blockDivisor);
            if (!nodeTextValue.length) {
                return acc;
            }
        }
        var nextNode = rootNode.content[i + 1];
        var isNextNodeBlock = nextNode && rich_text_types_1.helpers.isBlock(nextNode);
        var divisor = isNextNodeBlock ? blockDivisor : '';
        return acc + nodeTextValue + divisor;
    }, '');
}
exports.documentToPlainTextString = documentToPlainTextString;
//# sourceMappingURL=index.js.map